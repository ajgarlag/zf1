<sect1 id="zend.controller.front">
    <title>Фронт-контроллер</title>

    <sect2 id="zend.controller.front.overview">
        <title>Обзор<!--Overview--></title>

        <para>
            <code>Zend_Controller_Front</code> реализует
            <ulink url="http://www.martinfowler.com/eaaCatalog/frontController.html">паттерн
            Front Controller</ulink>, используемый в приложениях MVC. Его
            назначение состоит в инициализации окружении запроса, проложении
            маршрута приходящего запроса и последующем запуске выявленных
            действий. Он агрегирует все ответы и возвращает их по завершении
            процесса.
<!--
            <code>Zend_Controller_Front</code> implements a <ulink url="http://www.martinfowler.com/eaaCatalog/frontController.html">Front
                Controller pattern</ulink> used in <ulink url="http://en.wikipedia.org/wiki/Model-view-controller">Model-View-Controller
                (MVC)</ulink> applications. Its purpose is to initialize the
            request environment, route the incoming request, and then dispatch
            any discovered actions; it aggregates any responses and returns them
            when the process is complete.
-->
        </para>

        <para>
            <code>Zend_Controller_Front</code> также реализует
            <ulink url="http://en.wikipedia.org/wiki/Singleton_pattern">паттерн
            Singleton</ulink>, это означает, что в любое время может быть
            доступен только один экземпляр этого класса. Это позволяет ему также
            выступать в качестве реестра, в котором хранятся другие объекты,
            участвующие в процессе диспетчеризации.
<!--
            <code>Zend_Controller_Front</code> also implements the <ulink url="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton
            pattern</ulink>, meaning only a single instance of it may be available at
            any given time. This allows it to also act as a registry on which
            the other objects in the dispatch process may draw.
-->
        </para>

        <para>
            <code>Zend_Controller_Front</code> регистрирует в себе <link
            linkend="zend.controller.plugins">брокер плагинов</link> (plugin
            broker), что позволяет с помощью плагинов отслеживать события,
            инициируемые фронт-контроллером.
            В большинстве случаев это дает возможность подгонять
            процесс диспетчеризации под конкретный сайт без расширения
            фронт-контроллера для добавления функциональности.
<!--
            <code>Zend_Controller_Front</code> registers a <link linkend="zend.controller.plugins">plugin broker</link> with
            itself, allowing various events it triggers to be observed by
            plugins. In most cases, this gives the developer the opportunity to
            tailor the dispatch process to the site without the need to extend
            the front controller to add functionality.
-->
        </para>

        <para>
            Фронт-контроллеру для его работы необходим, как минимум,
            один или более путей к директориям, содержащим
            <link linkend="zend.controller.action">контроллеры действий</link>.
            Можно также использовать различные методы для дальнейшей
            настройки конфигураций фронт-контроллера и его помощников.
<!--
            At a bare minimum, the front controller needs one or more paths to
            directories containing <link linkend="zend.controller.action">action
                controllers</link> in order to do its work. A variety of methods
            may also be invoked to further tailor the front controller
            environment and that of its helper classes.
-->
        </para>
        
        <note>
            <title>Поведение по умолчанию<!--Default Behaviour--></title>
            <para>
                По умолчанию фронт-контроллер загружает плагин <link
                linkend="zend.controller.plugins.standard.errorhandler">ErrorHandler</link>
                и помощник действий <link
                linkend="zend.controller.actionhelpers.viewrenderer">ViewRenderer</link>.
                Это сделано для упрощения обработки ошибок и рендеринга видов в
                контроллерах, соответственно.
<!--
                By default, the front controller loads the <link
                    linkend="zend.controller.plugins.standard.errorhandler">ErrorHandler</link>
                plugin, as well as the <link
                    linkend="zend.controller.actionhelpers.viewrenderer">ViewRenderer</link>
                action helper plugin. These are to simplify error handling and
                view renderering in your controllers, respectively.
-->
            </para>

            <para>
                Для того, чтобы отключить <code>ErrorHandler</code>, произведите
                следующее в любой точке кода до вызова метода
                <code>dispatch()</code>:
<!--
                To disable the <code>ErrorHandler</code>, perform the following
                at any point prior to calling <code>dispatch()</code>:
-->
            </para>

            <programlisting role="php"><![CDATA[<?php
// Отключение плагина ErrorHandler:
$front->setParam('noErrorHandler', true);]]>
            </programlisting>

            <para>
                Для того, чтобы отключить <code>ViewRenderer</code>, сделайте
                следующее до вызова метода <code>dispatch()</code>:
<!--
                To disable the <code>ViewRenderer</code>, do the following prior
                to calling <code>dispatch()</code>:
-->
            </para>

            <programlisting role="php"><![CDATA[<?php
// Отключение помощника ViewRenderer:
$front->setParam('noViewRenderer', true);]]>
            </programlisting>
        </note>
        
    </sect2>

    <sect2 id="zend.controller.front.methods.primary">
        <title>Ключевые методы<!--Primary Methods--></title>

        <para>
            Фронт-контроллер имеет несколько аксессоров для настройки его
            конфигурации. Тем не менее, он имеет несколько ключевых в
            его функционале методов.
<!--
            The front controller has several accessors for setting up its
            environment. However, there are three primary methods key to the
            front controller's functionality:
-->
        </para>

        <sect3 id="zend.controller.front.methods.primary.getinstance">
            <title>getInstance()</title>
            
            <para>
                <code>getInstance()</code> используется для получения экземпляра
                фронт-контроллера. Поскольку фронт-контроллер реализует паттерн
                Singleton, то это также единственно доступный способ
                инстанцирования объекта фронт-контроллера.
<!--
                <code>getInstance()</code> is used to retrieve a front
                controller instance. As the front controller implements a
                Singleton pattern, this is also the only means possible for
                instantiating a front controller object.
-->
            </para>

            <programlisting role="php"><![CDATA[<?php
$front = Zend_Controller_Front::getInstance();]]>
            </programlisting>
        </sect3>

        <sect3 id="zend.controller.front.methods.primary.setcontrollerdirectory">
            <title>setControllerDirectory() и addControllerDirectory()</title>

            <para>
                <code>setControllerDirectory()</code> используется для того,
                чтобы указать <link
                linkend="zend.controller.dispatcher">диспетчеру</link>, где
                искать файлы классов <link
                linkend="zend.controller.action">контроллеров действий</link>.
                Он принимает один путь или ассоциативный массив пар
                модуль => путь в качестве параметра.
<!--
                <code>setControllerDirectory()</code> is used to tell <link linkend="zend.controller.dispatcher">the dispatcher</link>
                where to look for <link linkend="zend.controller.action">action controller</link>
                class files.  It accepts either a single path or an associative
                array of module/path pairs.
-->
            </para>

            <para>
                Примеры:
<!--
                As some examples:
-->
            </para>

            <programlisting role="php"><![CDATA[
// Установка директории контроллеров, используемой по умолчанию:
$front->setControllerDirectory('../application/controllers');

// Одновременная установка нескольких директорий модулей:
$front->setControllerDirectory(array(
    'default' => '../application/controllers',
    'blog'    => '../modules/blog/controllers',
    'news'    => '../modules/news/controllers',
));

// Добавление директории модуля 'foo':
$front->addControllerDirectory('../modules/foo/controllers', 'foo');]]>
            </programlisting>

            <note>
                <para>
                    Если вы используете <code>addControllerDirectory()</code>
                    без имени модуля, то он установит директорию для модуля
                    <code>default</code>. Если директория уже существует, то она
                    будет перезаписана.
<!--
                    If you use <code>addControllerDirectory()</code> without a
                    module name, it will set the directory for the
                    <code>default</code> module - overwriting it if it already
                    exists.
-->
                </para>
            </note>

            <para>
                Можно получить текущие установки для директорий
                контроллеров, используя метод
                <code>getControllerDirectory()</code>. Он вернет массив пар
                модуль => директория.
<!--
                You can get the current settings for the controller directory
                using <code>getControllerDirectory()</code>; this will return an
                array of module/directory pairs.
-->
            </para>
        </sect3>
            
        <sect3 id="zend.controller.front.methods.primary.dispatch">
            <title>dispatch()</title>

            <para>
                <code>dispatch(Zend_Controller_Request_Abstract $request = null,
                    Zend_Controller_Response_Abstract $response = null)</code>
                    является "рабочей лошадкой" фронт-контроллера. Он может
                    опционально принимать
                    <link linkend="zend.controller.request">объект
                    запроса</link> и/или
                    <link linkend="zend.controller.response">объект
                    ответа</link>, что дает разработчикам возможность передавать
                    свои объекты.
<!--
                <code>dispatch(Zend_Controller_Request_Abstract $request = null,
                    Zend_Controller_Response_Abstract $response = null)</code>
                does the heavy work of the front controller. It may optionally
                take a <link linkend="zend.controller.request">request
                    object</link> and/or a <link linkend="zend.controller.response">response object</link>,
                allowing the developer to pass in custom objects for each.
-->
            </para>

            <para>
                Если методу <code>dispatch()</code> не были переданы объект
                запроса или ответа, то он будет проверять, были ли ранее
                зарегистрированы объекты, и использовать их, либо инстанцировать
                версии по умолчанию (в обоих случаях по умолчанию будут
                использоваться разновидность HTTP).
<!--
                If no request or response object are passed in,
                <code>dispatch()</code> will check for previously registered
                objects and use those or instantiate default versions to use in
                its process (in both cases, the HTTP flavor will be used as the
                default).
-->
            </para>

            <para>
                Аналогичным образом <code>dispatch()</code> производит проверку
                на уже зарегистрированные объекты
                <link linkend="zend.controller.router">маршрутизатора</link> и
                <link linkend="zend.controller.dispatcher">диспетчера</link>, и
                если они не найдены, то инстанцирует версии по умолчанию.
<!--
                Similarly, <code>dispatch()</code> checks for registered <link linkend="zend.controller.router">router</link> and <link linkend="zend.controller.dispatcher">dispatcher</link>
                objects, instantiating the default versions of each if none is
                found.
-->
            </para>

            <para>
                Процесс диспетчеризации имеет три отдельных события:
<!--
                The dispatch process has three distinct events:
-->
            </para>

            <itemizedlist>
                <listitem><para>
                    Маршрутизация
                    <!--Routing-->
                </para></listitem>
                <listitem><para>
                    Диспетчеризация
                    <!--Dispatching-->
                </para></listitem>
                <listitem><para>
                    Ответ
                    <!--Response-->
                </para></listitem>
            </itemizedlist>

            <para>
                Маршрутизация производится только один раз, когда вызывается
                <code>dispatch()</code>, при этом используются значения в
                объекте запроса. Диспетчеризация производится циклически. Запрос
                может означать вызов нескольких действий, контроллер или плагин
                могут сбрасывать объект запроса для дополнительного вызова
                других действий. Когда все действия выполнены, фронт-контроллер
                возвращает ответ.
<!--
                Routing takes place exactly once, using the values in the
                request object when <code>dispatch()</code> is called.
                Dispatching takes place in a loop; a request may either indicate
                multiple actions to dispatch, or the controller or a plugin may
                reset the request object to force additional actions to
                dispatch. When all is done, the front controller returns a
                response.
-->
            </para>
        </sect3>

        <sect3 id="zend.controller.front.methods.primary.run">
            <title>run()</title>

            <para>
                <code>Zend_Controller_Front::run($path)</code> - статический
                метод, принимающий только путь к директории контроллеров. Он
                извлекает экземпляр фронт-контроллера через
                <link linkend="zend.controller.front.methods.primary.getinstance">getInstance()</link>),
                регистрирует этот путь через
                <link linkend="zend.controller.front.methods.primary.setcontrollerdirectory">setControllerDirectory()</link>, и в конце вызывает метод <link linkend="zend.controller.front.methods.primary.dispatch">dispatch()</link>.
<!--
                <code>Zend_Controller_Front::run($path)</code> is a static
                method taking simply a path to a directory containing
                controllers. It fetches a front controller instance (via
                <link linkend="zend.controller.front.methods.primary.getinstance">getInstance()</link>,
                registers the path provided via <link linkend="zend.controller.front.methods.primary.setcontrollerdirectory">setControllerDirectory()</link>,
                and finally <link linkend="zend.controller.front.methods.primary.dispatch">dispatches</link>.
-->
            </para>

            <para>
                В сущности, <code>run()</code> представляет собой удобный
                метод, который можно использовать при разработке сайта, не
                требующего специальной настройки фронт-контроллера.
<!--
                Basically, <code>run()</code> is a convenience method that can
                be used for site setups that do not require customization of the
                front controller environment.
-->
            </para>

            <programlisting role="php"><![CDATA[<?php
// Инстанцирование фронт-контроллера, установка директории контроллера и
// выполнение диспетчеризации одной строкой:
Zend_Controller_Front::run('../application/controllers');]]>
            </programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.controller.front.methods.environment">
        <title>Методы-аксессоры для конфигурирования<!--Environmental Accessor Methods--></title>

        <para>
            Кроме методов, перечисленных выше, есть методы-аксессоры, которые
            можно использовать для управления конфигурацией фронт-контроллера -
            и одновременно конфигурацией классов, которым фронт-контроллер
            делегирует выполнение.
<!--
            In addition to the methods listed above, there are a number of
            accessor methods that can be used to affect the front controller
            environment - and thus the environment of the classes to which the
            front controller delegates.
-->
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>resetInstance()</code> может использоваться для сброса
                    всех текущих настроек. Он в основном предназначен для
                    тестирования, но может также использоваться в тех случаях,
                    когда нужно связать между собой несколько
                    фронт-контроллеров.
<!--
                    <code>resetInstance()</code> can be used to clear all
                    current settings. Its primary purpose is for testing, but it
                    can also be used for instances where you wish to chain
                    together multiple front controllers.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>(set|get)DefaultControllerName()</code> позволяют
                    установить другое имя используемого
                    по умолчанию контроллера (иначе используется 'index') и
                    получить текущее значение. Они служат посредниками к
                    <link linkend="zend.controller.dispatcher">диспетчеру</link>.
<!--
                    <code>(set|get)DefaultControllerName()</code> let you
                    specify a different name to use for the default controller
                    ('index' is used otherwise) and retrieve the current value.
                    They proxy to <link linkend="zend.controller.dispatcher">the
                        dispatcher</link>.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>(set|get)DefaultActionName()</code> позволяют
                    установить другое имя используемого по умолчанию действия
                    (иначе используется 'index') и получить текущее
                    значение. Они служат посредниками к
                    <link linkend="zend.controller.dispatcher">диспетчеру</link>.
<!--
                    <code>(set|get)DefaultActionName()</code> let you specify a
                    different name to use for the default action ('index' is
                    used otherwise) and retrieve the current value.  They proxy
                    to <link linkend="zend.controller.dispatcher">the
                        dispatcher</link>.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>(set|get)Request()</code> позволяют установить
                    класс <link linkend="zend.controller.request">запроса</link>
                    или его объект для использования в процессе диспетчеризации
                    и получить текущий объект. При установке объекта
                    запроса вы можете передать имя класса запроса, в этом случае
                    метод загрузит файл класса и инстанцирует его.
<!--
                    <code>(set|get)Request()</code> let you specify <link linkend="zend.controller.request">the request</link>
                    class or object to use during the dispatch process and to
                    retrieve the current object. When setting the request
                    object, you may pass in a request class name, in which case
                    the method will load the class file and instantiate it.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>(set|get)Router()</code> позволяют установить
                    класс
                    <link linkend="zend.controller.router">маршрутизатора</link>
                    или его объект, используемые в течение процесса
                    диспетчеризации, и получить текущий объект. Когда
                    устанавливается объект маршрутизатора, вы можете передать
                    имя класса маршрутизатора, в этом случае метод загрузит файл
                    класса и инстанцирует его.
<!--
                    <code>(set|get)Router()</code> let you specify <link linkend="zend.controller.router">the router</link>
                    class or object to use during the dispatch process and to
                    retrieve the current object. When setting the router
                    object, you may pass in a router class name, in which case
                    the method will load the class file and instantiate it.
-->
                </para>

                <para>
                    При извлечении объекта маршрутизатора сначала производится
                    проверка, представлен ли во фронт-контроллере такой объект и
                    в случае его отсутствия инстанцирует испольуемый по
                    умолчанию маршрутизатор (Rewrite Router).
<!--
                    When retrieving the router object, it first checks to see if
                    one is present, and if not, instantiates the default router
                    (rewrite router).
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>(set|get)BaseUrl()</code> дают возможность установить
                    <link linkend="zend.controller.request.http.baseurl">базовый
                    URL</link>, который удаляется из начала при
                    маршрутизации запросов, и получить его текущее значение.
                    Это значение передается объекту запроса непосредственно до
                    маршрутизации.
<!--
                    <code>(set|get)BaseUrl()</code> let you specify <link linkend="zend.controller.request.http.baseurl">the base
                        URL</link> to strip when routing requests and to
                    retrieve the current value. The value is provided to the
                    request object just prior to routing.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>(set|get)Dispatcher()</code> дают возможность
                    установки класса
                    <link linkend="zend.controller.dispatcher">диспетчера</link>
                    или его объекта для использования в течение диспетчеризации,
                    и получения текущего объекта. При установке объекта
                    диспетчера можно передать имя класса диспетчера, в этом
                    случае метод загрузит файл класса и инстанцирует его.
<!--
                    <code>(set|get)Dispatcher()</code> let you specify <link linkend="zend.controller.dispatcher">the
                        dispatcher</link> class or object to use during the
                    dispatch process and retrieve the current object. When
                    setting the dispatcher object, you may pass in a dispatcher
                    class name, in which case the method will load the class
                    file and instantiate it.
-->
                </para>

                <para>
                    При извлечении объекта диспетчера, метод сначала производит
                    проверку того, представлен ли во фронт-контроллере такой
                    объект и в случае его отсутствия инстанцирует диспетчер,
                    используемый по умолчанию.
<!--
                    When retrieving the dispatcher object, it first checks to see if
                    one is present, and if not, instantiates the default
                    dispatcher.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>(set|get)Response()</code> дают возможность установить
                    класс <link linkend="zend.controller.response">ответа</link>
                    или его объект для использования в процессе диспетчеризации,
                    и извлечь текущий объект. При установке объекта
                    ответа можно передать имя класса ответа, в этом случае метод
                    загрузит файл класса и инстанцирует его.
<!--
                    <code>(set|get)Response()</code> let you specify <link linkend="zend.controller.response">the response</link>
                    class or object to use during the dispatch process and to
                    retrieve the current object. When setting the response
                    object, you may pass in a response class name, in which case
                    the method will load the class file and instantiate it.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>registerPlugin(Zend_Controller_Plugin_Abstract $plugin, $stackIndex = null)</code>
                    позволяет регистрировать <link
                        linkend="zend.controller.plugins">объекты плагинов</link>.
                    Путем установки опционального параметра
                    <code>$stackIndex</code>, вы можете 
                    контролировать порядок, в котором выполняются плагины.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>unregisterPlugin($plugin)</code> позволяет отменять
                    регистрацию <link
                        linkend="zend.controller.plugins">объектов плагинов</link>.
                    <code>$plugin</code> может быть как объектом плагина, так и строкой, обозначающей класс плагина, регистрацию которого надо отменить.
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>throwExceptions($flag)</code> используется для
                    включения/отключения возможности генерации исключений в
                    течение процесса диспетчеризации. По умолчанию исключения
                    отлавливаются и размещаются в
                    <link linkend="zend.controller.response">объекте
                    ответа</link>; включение <code>throwExceptions()</code>
                    переопределит это поведение
<!--
                    <code>throwExceptions($flag)</code> is used to turn on/off
                    the ability to throw exceptions during the dispatch process.
                    By default, exceptions are caught and placed in the <link linkend="zend.controller.response">response
                        object</link>; turning on <code>throwExceptions()</code>
                    will override this behaviour.
-->
                </para>

                <para>
                    Более полробную информацию читайте в <xref linkend="zend.controller.exceptions"/>.
<!--
                    For more information, read <xref linkend="zend.controller.exceptions"/>.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>returnResponse($flag)</code> используется для того,
                    чтобы указать фронт-контроллеру - возвращать ли ответ
                    из <code>dispatch()</code> (<code>true</code>), либо ответ
                    должен быть отправлен автоматически (<code>false</code>). По
                    умолчанию ответ отправляется автоматически
                    (через вызов
                    <code>Zend_Controller_Response_Abstract::sendResponse()</code>);
                    включение <code>returnResponse()</code> переопределит это
                    поведение.
<!--
                    <code>returnResponse($flag)</code> is used to tell the front
                    controller whether to return the response
                    (<code>true</code>) from <code>dispatch()</code>, or if the
                    response should be automatically emitted
                    (<code>false</code>).  By default, the response is
                    automatically emitted (by calling
                    <code>Zend_Controller_Response_Abstract::sendResponse()</code>);
                    turning on <code>returnResponse()</code> will override this
                    behaviour.
-->
                </para>

                <para>
                    Ситуации, в которых может потребоваться возврат ответа,
                    включают в себя проверку на предмет исключений до отправки
                    ответа клиенту, необходимость журналирования различных
                    аспектов ответа (таких, как заголовки) и т.д.
<!--
                    Reasons to return the response include a desire to check for
                    exceptions prior to emitting the response, needing to log
                    various aspects of the response (such as headers), etc.
-->
                </para>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.controller.front.methods.params">
        <title>Параметры фронт-контроллера<!--Front Controller Parameters--></title>

        <para>
            Во введении мы указали на то, что фронт-контроллер также выступает
            как реестр для различных компонент контроллера. Это реализуется
            через группу методов для параметров. Эти методы позволяют
            регистрировать произвольные данные - объекты и переменные - во
            фронт-контроллере, чтобы их можно было извлечь в любой точке цепочки
            диспетчеризации. Эти значения передаются маршрутизатору, диспетчеру,
            и контроллерам действий. Эти методы включают в себя:
<!--
            In the introduction, we indicated that the front controller also
            acts as a registry for the various controller components. It does so
            through a family of "param" methods. These methods allow you to
            register arbitrary data - objects and variables - with the front
            controller to be retrieved at any time in the dispatch chain. These
            values are passed on to the router, dispatcher, and action
            controllers. The methods include:
-->
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>setParam($name, $value)</code> дает возможность
                    установить единственный параметр с именем <code>$name</code>
                    и значением <code>$value</code>.
<!--
                    <code>setParam($name, $value)</code> allows you to set a
                    single parameter of <code>$name</code> with value
                    <code>$value</code>.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>setParams(array $params)</code> позволяет
                    установить несколько параметров одновременно с помощью
                    ассоциативного массива.
<!--
                    <code>setParams(array $params)</code> allows you to set
                    multiple parameters at once using an associative array.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>getParam($name)</code> дает возможность извлечь один
                    параметр за один раз, используя его имя <code>$name</code> в
                    качестве идентификатора.
<!--
                    <code>getParam($name)</code> allows you to retrieve a single
                    parameter at a time, using <code>$name</code> as the
                    identifier.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>getParams()</code> позволяет извлечь все
                    параметры за один раз.
<!--
                    <code>getParams()</code> allows you to retrieve the entire
                    list of parameters at once.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>clearParams()</code> позволяет удалить один параметр
                    (путем передачи строкового идентификатора), нескольких
                    параметров (путем передачи массива строковых
                    идентификаторов) или весь стек параметров (без передачи
                    чего-либо).
<!--
                    <code>clearParams()</code> allows you to clear a single
                    parameter (by passing a string identifier), multiple named
                    parameters (by passing an array of string identifiers), or the
                    entire parameter stack (by passing nothing).
-->
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Есть несколько предопределенных параметров специально для
            использования в цепочке диспетчеризации:
<!--
            There are several pre-defined parameters that may be set that have
            specific uses in the dispatch chain:
-->
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <code>useDefaultControllerAlways</code> используется для
                    указания
                    <link linkend="zend.controller.dispatcher">диспетчеру</link>,
                    что следует использовать контроллер по умолчанию в модуле
                    по умолчанию для любых запросов, диспетчеризация которых
                    невозможна (т.е. модуль, контроллер и/или действие не
                    существуют). По умолчанию он отключен.
<!--
                    <code>useDefaultControllerAlways</code> is used to hint to
                    <link linkend="zend.controller.dispatcher">the
                        dispatcher</link> to use the default controller in the
                    default module for any request that is not dispatchable
                    (i.e., the module, controller, and/or action do not exist).
                    By default, this is off.
-->
                </para>

                <para>
                    См. <xref linkend="zend.controller.exceptions.internal"/> за
                    более подробной информацией об использовании этого параметра
                    настройки.
<!--
                    See <xref linkend="zend.controller.exceptions.internal"/>
                    for more detailed information on using this setting.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>disableOutputBuffering</code> используется для
                    указания
                    <link linkend="zend.controller.dispatcher">диспетчеру</link>,
                    что не следует использовать буферизацию вывода для сбора
                    данных на вывод, генерируемых контроллерами действий. По
                    умолчанию диспетчер собирает весь вывод и присоединяет его к
                    телу содержимого в объекте ответа.
<!--
                    <code>disableOutputBuffering</code> is used to hint to <link linkend="zend.controller.dispatcher">the
                        dispatcher</link> that it should not use output
                    buffering to capture output generated by action controllers.
                    By default, the dispatcher captures any output and appends
                    it to the response object body content.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>noViewRenderer</code> используется для отключения
                    помощника <link
                        linkend="zend.controller.actionhelpers.viewrenderer">ViewRenderer</link>.
                    Установите этот параметр в true для его отключения.
<!--
                    <code>noViewRenderer</code> is used to disable the <link
                        linkend="zend.controller.actionhelpers.viewrenderer">ViewRenderer</link>.
                    Set this parameter to true to disable it.
-->
                </para>
            </listitem>

            <listitem>
                <para>
                    <code>noErrorHandler</code> используется для отключения
                    <link
                        linkend="zend.controller.plugins.standard.errorhandler">плагина
                        Error Handler</link>
                    Установите этот параметр в true для его отключения.
<!--
                    <code>noErrorHandler</code> is used to disable the <link
                        linkend="zend.controller.plugins.standard.errorhandler">Error
                        Handler plugin</link>. Set this parameter to true to
                    disable it.
-->
                </para>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2 id="zend.controller.front.subclassing">
        <title>Создание подклассов фронт-контроллера<!--Subclassing the Front Controller--></title>

        <para>
            При создании подкласса фронт-контроллера, необходимо, как
            минимум, переопределить метод <code>getInstance()</code>.
<!--
            To subclass the Front Controller, at the very minimum you will need
            to override the <code>getInstance()</code> method:
-->
        </para>

        <programlisting role="php"><![CDATA[
class My_Controller_Front extends Zend_Controller_Front
{
    public static function getInstance()
    {
        if (null === self::$_instance) {
            self::$_instance = new self();
        }

        return self::$_instance;
    }
}
]]>
        </programlisting>

        <para>
            Такое переопределение метода <code>getInstance()</code> гарантирует
            то, что последующий вызов
            <code>Zend_Controller_Front::getInstance()</code> вернет экземпляр
            созданного вами подкласса вместо экземпляра
            <code>Zend_Controller_Front</code> - это особенно полезно для
            некоторых альтернативных маршрутизаторов и помощников видов.
<!--
            Overriding the <code>getInstance()</code> method ensures that
            subsequent calls to
            <code>Zend_Controller_Front::getInstance()</code> will return an
            instance of your new subclass instead of a
            <code>Zend_Controller_Front</code> instance - this is particularly
            useful for some of the alternate routers and view helpers. 
-->
        </para>

        <para>
            Как правило, нет необходимости создавать подклассы
            фронт-контроллера, если только не нужно добавить новый
            функционал (например, автозагрузку плагинов или способ
            определения путей к помощникам действий). Целями, для достижения
            которых может потребоваться изменение поведения фронт-контроллера,
            могут быть изменение принципа хранения директорий
            контроллеров, установка других используемых по умолчанию
            маршрутизатора и диспетчера и т.д.
<!--
            Typically, you will not need to subclass the front controller unless
            you need to add new functionality (for instance, a plugin
            autoloader, or a way to specify action helper paths). Some points
            where you may want to alter behaviour may include modifying how
            controller directories are stored, or what default router or
            dispatcher are used.
-->
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->